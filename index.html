<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas - AI Interactive Tree</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
    <style>
        :root {
            --gold: #d4af37;
            --cream: #fceea7;
        }
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Times New Roman', serif; }
        
        /* UI Styles */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; transition: opacity 0.8s ease; z-index: 10;
        }
        .ui-hidden { opacity: 0; pointer-events: none; }

        h1 {
            position: absolute; top: 5%; width: 100%; text-align: center;
            font-family: 'Cinzel', serif; font-size: 56px; margin: 0;
            background: linear-gradient(to bottom, #ffffff, var(--gold));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 15px rgba(212, 175, 55, 0.5));
        }

        .upload-wrapper {
            position: absolute; bottom: 10%; left: 50%; transform: translateX(-50%);
            pointer-events: auto; text-align: center;
        }

        #upload-btn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid var(--gold);
            color: var(--gold);
            padding: 12px 30px;
            font-size: 18px; cursor: pointer;
            letter-spacing: 2px; transition: 0.3s;
        }
        #upload-btn:hover { background: var(--gold); color: #000; }

        .hint { color: rgba(252, 234, 167, 0.6); margin-top: 10px; font-size: 12px; }

        /* Loader */
        #loader {
            position: fixed; inset: 0; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; transition: opacity 1s;
        }
        .spinner {
            width: 40px; height: 40px;
            border: 2px solid rgba(212, 175, 55, 0.1);
            border-top: 1px solid var(--gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        #loader p { color: var(--gold); margin-top: 20px; letter-spacing: 4px; font-size: 14px; }

        @keyframes spin { to { transform: rotate(360deg); } }

        /* CV Hidden elements */
        #video-container { position: absolute; bottom: 0; right: 0; opacity: 0; pointer-events: none; }
    </style>
</head>
<body>

<div id="loader">
    <div class="spinner"></div>
    <p>LOADING HOLIDAY MAGIC</p>
</div>

<div id="ui-layer">
    <h1>Merry Christmas</h1>
    <div class="upload-wrapper">
        <button id="upload-btn">ADD MEMORIES</button>
        <div class="hint">Press 'H' to Hide Controls</div>
        <input type="file" id="image-input" hidden accept="image/*">
    </div>
</div>

<div id="video-container">
    <video id="webcam" autoplay playsinline></video>
</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    import { FilesetResolver, GestureRecognizer } from '@mediapipe/tasks-vision';

    class ChristmasTreeApp {
        constructor() {
            this.container = document.body;
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.camera.position.set(0, 15, 45);
            
            this.renderer = new THREE.WebGLRenderer({ antialias: true });
            this.renderer.setPixelRatio(window.devicePixelRatio);
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.toneMapping = THREE.ReinhardToneMapping;
            this.renderer.toneMappingExposure = 2.2;
            document.body.appendChild(this.renderer.domElement);

            this.handPos = new THREE.Vector3(0, 0, 0);
            this.initLights();
            this.initPostProcessing();
            this.initEnvironment();
            this.createCandyTexture();
            this.createTree();
            this.createPhotoFrame("JOYEUX NOEL");
            this.initCV();
            this.addEventListeners();
            this.animate();
        }

        initLights() {
            this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const pointLight = new THREE.PointLight(0xffaa00, 2);
            pointLight.position.set(0, 10, 0);
            this.scene.add(pointLight);

            const spot1 = new THREE.SpotLight(0xd4af37, 1200);
            spot1.position.set(30, 40, 40);
            this.scene.add(spot1);

            const spot2 = new THREE.SpotLight(0x00aaff, 600);
            spot2.position.set(-30, 20, -30);
            this.scene.add(spot2);
        }

        initPostProcessing() {
            this.composer = new EffectComposer(this.renderer);
            this.composer.addPass(new RenderPass(this.scene, this.camera));
            const bloom = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.45, 0.4, 0.7
            );
            this.composer.addPass(bloom);
        }

        initEnvironment() {
            const pmremGenerator = new THREE.PMREMGenerator(this.renderer);
            this.scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
        }

        createCandyTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 128, 128);
            ctx.strokeStyle = '#cc0000';
            ctx.lineWidth = 15;
            for(let i=0; i<4; i++) {
                ctx.beginPath();
                ctx.moveTo(-50 + i*50, 0);
                ctx.lineTo(128, 128 - (i*50 - 50));
                ctx.stroke();
            }
            this.candyTexture = new THREE.CanvasTexture(canvas);
            this.candyTexture.wrapS = this.candyTexture.wrapT = THREE.RepeatWrapping;
            this.candyTexture.repeat.set(2, 8);
        }

        createTree() {
            this.treeGroup = new THREE.Group();
            
            // Particles
            const count = 1500;
            for (let i = 0; i < count; i++) {
                const ratio = i / count;
                const angle = ratio * Math.PI * 40;
                const radius = (1 - ratio) * 15;
                const y = ratio * 35 - 15;
                
                let geometry;
                const rand = Math.random();
                if(rand > 0.6) geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                else geometry = new THREE.SphereGeometry(0.3, 8, 8);

                const material = new THREE.MeshPhysicalMaterial({
                    color: Math.random() > 0.5 ? 0xd4af37 : 0x0a3d0a,
                    metalness: 0.9, roughness: 0.1,
                    clearcoat: 1.0
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
                mesh.userData = { 
                    originalPos: mesh.position.clone(),
                    speed: 0.02 + Math.random() * 0.05 
                };
                this.treeGroup.add(mesh);
            }

            // Candy Canes
            for(let i=0; i<12; i++) {
                const curve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 4, 0),
                    new THREE.Vector3(1, 5, 0),
                    new THREE.Vector3(2, 4, 0),
                ]);
                const tubeGeo = new THREE.TubeGeometry(curve, 20, 0.3, 8, false);
                const tubeMat = new THREE.MeshStandardMaterial({ map: this.candyTexture });
                const cane = new THREE.Mesh(tubeGeo, tubeMat);
                const angle = (i / 12) * Math.PI * 2;
                const r = 8;
                cane.position.set(Math.cos(angle)*r, Math.random()*20 - 5, Math.sin(angle)*r);
                cane.rotation.y = -angle;
                this.treeGroup.add(cane);
            }

            this.scene.add(this.treeGroup);

            // Dust
            const dustGeo = new THREE.BufferGeometry();
            const dustPos = [];
            for(let i=0; i<2500; i++) {
                dustPos.push((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
            }
            dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(dustPos, 3));
            const dustMat = new THREE.PointsMaterial({ color: 0xfceea7, size: 0.05, transparent: true, opacity: 0.5 });
            this.dust = new THREE.Points(dustGeo, dustMat);
            this.scene.add(this.dust);
        }

        createPhotoFrame(textOrImg) {
            if(this.photoFrame) this.scene.remove(this.photoFrame);
            
            const group = new THREE.Group();
            const frameGeo = new THREE.BoxGeometry(10.5, 7.5, 0.5);
            const frameMat = new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 0.8 });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 384;
            const ctx = canvas.getContext('2d');
            
            if(typeof textOrImg === 'string') {
                ctx.fillStyle = '#111';
                ctx.fillRect(0,0,512,384);
                ctx.fillStyle = '#fceea7';
                ctx.font = 'bold 40px Cinzel';
                ctx.textAlign = 'center';
                ctx.fillText(textOrImg, 256, 200);
            } else {
                ctx.drawImage(textOrImg, 0, 0, 512, 384);
            }

            const photoGeo = new THREE.PlaneGeometry(10, 7);
            const photoMat = new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas) });
            const photo = new THREE.Mesh(photoGeo, photoMat);
            photo.position.z = 0.3;

            group.add(frame, photo);
            group.position.set(0, 0, 15);
            this.photoFrame = group;
            this.scene.add(this.photoFrame);
        }

        async initCV() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            this.gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });
            
            const video = document.getElementById('webcam');
            navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                video.srcObject = stream;
                document.getElementById('loader').style.opacity = '0';
                setTimeout(() => document.getElementById('loader').remove(), 1000);
            });
        }

        addEventListeners() {
            window.addEventListener('resize', () => {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            });

            window.addEventListener('keydown', (e) => {
                if(e.key.toLowerCase() === 'h') document.getElementById('ui-layer').classList.toggle('ui-hidden');
            });

            const input = document.getElementById('image-input');
            document.getElementById('upload-btn').onclick = () => input.click();
            input.onchange = (e) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => this.createPhotoFrame(img);
                    img.src = event.target.result;
                };
                reader.readAsDataURL(e.target.files[0]);
            };
        }

        animate() {
            requestAnimationFrame(() => this.animate());
            const time = Date.now() * 0.001;

            // MediaPipe Logic
            const video = document.getElementById('webcam');
            if (video.readyState === 4 && this.gestureRecognizer) {
                const results = this.gestureRecognizer.recognizeForVideo(video, performance.now());
                if (results.landmarks && results.landmarks.length > 0) {
                    const hand = results.landmarks[0][8]; // Index finger tip
                    this.handPos.x = (hand.x - 0.5) * 60;
                    this.handPos.y = (0.5 - hand.y) * 40;
                }
            }

            // Animate Tree and Particles
            this.treeGroup.rotation.y += 0.005;
            this.treeGroup.children.forEach(child => {
                if(child.userData.originalPos) {
                    const dist = child.position.distanceTo(this.handPos);
                    if(dist < 10) {
                        child.position.lerp(this.handPos, 0.05);
                    } else {
                        child.position.lerp(child.userData.originalPos, 0.02);
                    }
                    child.rotation.x += child.userData.speed;
                }
            });

            this.dust.rotation.y -= 0.001;
            if(this.photoFrame) {
                this.photoFrame.position.y = Math.sin(time) * 1 + 2;
                this.photoFrame.rotation.y = Math.sin(time * 0.5) * 0.2;
            }

            this.composer.render();
        }
    }

    new ChristmasTreeApp();
</script>

</body>
</html>

